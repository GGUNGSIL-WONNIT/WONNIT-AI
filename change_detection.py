# -*- coding: utf-8 -*-
"""change_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o8mmQ2fb-DFog2I7cerzP7E6eTfKzxM3
"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

!pip -q install timm tqdm

"""## 데이터셋 구축

train/val 데이터 분할
"""

# === 설정 ===
from pathlib import Path
import shutil, random

from pathlib import Path
import shutil, random

SRC = Path("/content/drive/MyDrive/gayoung/ba/label_space_data/dataset_trainval")
DST_T = Path("/content/drive/MyDrive/gayoung/ba/label_space_data/dataset_train")
DST_V = Path("/content/drive/MyDrive/gayoung/ba/label_space_data/dataset_val")
    # 출력(val)

TRAIN_RATIO = 0.8
RANDOM_SEED = 42                   # 재현성

# 파일 확장자(필요시 수정)
IMG_EXTS = {".jpg", ".jpeg", ".png", ".bmp", ".webp"}
LBL_EXT  = ".txt"                  # YOLO 형식 가정

random.seed(RANDOM_SEED)

def is_hidden(p: Path) -> bool:
    return p.name.startswith(".") or p.name.startswith("._")

def ensure_dir(p: Path):
    p.mkdir(parents=True, exist_ok=True)

# 존재하는 서브폴더만 사용(images/labels/preview 중 실제 있는 것만)
SUBS = [d.name for d in SRC.iterdir() if d.is_dir() and d.name in {"images","labels","preview"}]
print("대상 서브폴더:", SUBS)

# 클래스 목록은 images 기준으로 얻음
classes = sorted([d.name for d in (SRC/"images").iterdir() if d.is_dir() and not is_hidden(d)])
print("클래스:", classes)

# 통계
stats = {c: {"train":0, "val":0} for c in classes}
total_train = total_val = 0

for cls in classes:
    img_cls_dir = SRC/"images"/cls
    lbl_cls_dir = SRC/"labels"/cls

    # 이미지 파일 수집(숨김/리소스 파일 제외)
    imgs = [p for p in img_cls_dir.iterdir() if p.is_file() and not is_hidden(p) and p.suffix.lower() in IMG_EXTS]
    # 라벨이 존재하는 이미지만 남김(베이스네임 매칭)
    good = []
    for img in imgs:
        base = img.stem
        lbl  = lbl_cls_dir/(base + LBL_EXT)
        if lbl.exists() and not is_hidden(lbl):
            good.append((img, lbl))

    random.shuffle(good)
    k = int(len(good) * TRAIN_RATIO)
    train_pairs = good[:k]
    val_pairs   = good[k:]

    # 복사 함수
    def copy_pairs(pairs, split_root):
        img_out = split_root/"images"/cls
        lbl_out = split_root/"labels"/cls
        ensure_dir(img_out); ensure_dir(lbl_out)
        for img, lbl in pairs:
            shutil.copy2(img, img_out/img.name)
            shutil.copy2(lbl, lbl_out/lbl.name)
        return len(pairs)

    stats[cls]["train"] = copy_pairs(train_pairs, DST_T)
    stats[cls]["val"]   = copy_pairs(val_pairs,   DST_V)
    total_train += stats[cls]["train"]
    total_val   += stats[cls]["val"]

# preview 폴더가 있으면 동일 비율로 파일만 분할(라벨 없음)
if "preview" in SUBS:
    for cls in sorted([d.name for d in (SRC/"preview").iterdir() if d.is_dir() and not is_hidden(d)]):
        prev_cls_dir = SRC/"preview"/cls
        files = [p for p in prev_cls_dir.iterdir() if p.is_file() and not is_hidden(p)]
        random.shuffle(files)
        k = int(len(files) * TRAIN_RATIO)
        train_f, val_f = files[:k], files[k:]
        for dst_root, lst in [(DST_T, train_f), (DST_V, val_f)]:
            out_dir = dst_root/"preview"/cls
            ensure_dir(out_dir)
            for f in lst:
                shutil.copy2(f, out_dir/f.name)

# 결과 요약 출력
print("\n=== 분할 요약 ===")
for cls in classes:
    print(f"{cls:>20}: train {stats[cls]['train']:4d} | val {stats[cls]['val']:4d}")
print(f"\n총계 → train: {total_train}  /  val: {total_val}")
print("✅ 완료: /content/gayoung/ba/label_space_data/dataset_train & dataset_val")

"""**(train/val) Before/After + GT 마스크 생성**


1.  목표: 실제 환경과 유사한 다양한 변화(가림/블러/픽셀화/인페인트/이동)를 자동 적용해, (before, after, mask) 쌍을 일괄 생성
2. 마스크 규칙: 0=배경, 255=변경 영역
3. 활용: 변화 감지(Change Detection), 전/후 비교, 분할(Segmentation) 학습 및 벤치마킹



"""

import os, json, random, cv2, numpy as np
from pathlib import Path

random.seed(42)

# ====== 경로 설정 ======
BASE = Path("/content/drive/MyDrive/gayoung/ba/label_space_data")
IN_SPLITS = ["dataset_train","dataset_val"]  # 둘 다 처리
OUT = Path("/content/drive/MyDrive/gayoung/ba/pairs_out_cd")   # 결과

# ====== 파라미터 ======
IMG_EXTS = {".jpg",".jpeg",".png",".bmp",".webp"}
YOLO_LBL_EXT = ".txt"
APPLY_MASK_PROB = 0.85       # 이 확률로 변경 적용(낮추면 '변화 없음' 샘플도 섞임)
MASK_MODE_SET = ["black","inpaint","rect","blur","pixel"]  # 가림 방식 후보
RECT_JITTER = 0.12           # bbox 주변 랜덤 여유
PARTIAL_KEEP_PROB = 0.25     # 변경 영역 일부는 남김(부분 가림)
MIN_BOX_AREA = 20*20         # 너무 작은 박스는 생략
MAX_MOVED_TRIES = 10         # 이동 시도 횟수(경계 밖 방지)

def is_hidden(p: Path): return p.name.startswith(".") or p.name.startswith("._")

def ensure_dir(p: Path): p.mkdir(parents=True, exist_ok=True)

def read_yolo(txt_path: Path):
    boxes = []
    if not txt_path.exists(): return boxes
    for line in open(txt_path,"r"):
        ps = line.strip().split()
        if len(ps) < 5: continue
        # cls cx cy w h  (normalized)
        cls, cx, cy, w, h = ps[:5]
        try:
            cx, cy, w, h = map(float, (cx, cy, w, h))
            boxes.append((cx,cy,w,h))
        except:
            continue
    return boxes

def yolo_to_xywh(box, W, H):
    cx,cy,w,h = box
    bw, bh = int(w*W), int(h*H)
    x = int((cx - w/2)*W); y = int((cy - h/2)*H)
    x = max(0,x); y = max(0,y)
    x2 = min(W-1, x+bw); y2 = min(H-1, y+bh)
    return x,y, max(2,x2-x), max(2,y2-y)

def jitter_rect(x,y,w,h,W,H,rate):
    jx, jy = int(w*rate), int(h*rate)
    x = max(0, min(W-1, x + random.randint(-jx, jx)))
    y = max(0, min(H-1, y + random.randint(-jy, jy)))
    w = max(2, w + random.randint(-jx, jx))
    h = max(2, h + random.randint(-jy, jy))
    x2 = max(0, min(W-1, x+w)); y2 = max(0, min(H-1, y+h))
    return x, y, x2-x, y2-y

def non_overlapping(new_box, existing, min_iou=0.05):
    # new_box, existing: [x,y,w,h] in pixels
    def iou(a, b):
        ax1,ay1,aw,ah = a; ax2,ay2 = ax1+aw, ay1+ah
        bx1,by1,bw,bh = b; bx2,by2 = bx1+bw, by1+bh
        ix1, iy1 = max(ax1,bx1), max(ay1,by1)
        ix2, iy2 = min(ax2,bx2), min(ay2,by2)
        iw, ih = max(0, ix2-ix1), max(0, iy2-iy1)
        inter = iw*ih
        union = aw*ah + bw*bh - inter + 1e-6
        return inter/union
    return all(iou(new_box, b) <= min_iou for b in existing)

def inpaint_rect(img, x,y,w,h):
    mask = np.zeros(img.shape[:2], np.uint8)
    cv2.rectangle(mask,(x,y),(x+w,y+h),255,-1)
    return cv2.inpaint(img, mask, 3, cv2.INPAINT_TELEA)

def blur_rect(img, x,y,w,h):
    roi = img[y:y+h, x:x+w]
    if roi.size == 0: return img
    k = max(3, (min(w,h)//10)*2+1)
    img[y:y+h, x:x+w] = cv2.GaussianBlur(roi, (k,k), 0)
    return img

def pixelate_rect(img, x,y,w,h, factor=0.1):
    roi = img[y:y+h, x:x+w]
    if roi.size == 0: return img
    down_w, down_h = max(1,int(w*factor)), max(1,int(h*factor))
    small = cv2.resize(roi,(down_w,down_h), interpolation=cv2.INTER_LINEAR)
    img[y:y+h, x:x+w] = cv2.resize(small,(w,h), interpolation=cv2.INTER_NEAREST)
    return img

def paste_move(img, x,y,w,h, W,H, existing):
    """ 박스를 잘라서 새 위치로 '이동' (라벨용 변경 마스크엔 원위치와 새 위치 모두 반영) """
    src = img[y:y+h, x:x+w].copy()
    tries = 0
    while tries < MAX_MOVED_TRIES:
        nx = random.randint(0, max(0,W-w)); ny = random.randint(0, max(0,H-h))
        cand = [nx,ny,w,h]
        if non_overlapping(cand, existing, min_iou=0.1):
            img[ny:ny+h, nx:nx+w] = src
            # 원 위치는 검정으로 지우기
            img[y:y+h, x:x+w] = 0
            return img, cand
        tries += 1
    return img, None

def apply_change(after, change_mask, box_xywh, W,H):
    """ box를 약간 흔들고, 다양한 방식으로 가림/이동. change_mask에 변경 영역 반영 """
    x,y,w,h = box_xywh
    # 너무 작은 박스는 생략
    if w*h < MIN_BOX_AREA: return after, change_mask, None
    # 살짝 여유/흔들기
    x,y,w,h = jitter_rect(x,y,w,h,W,H, RECT_JITTER)

    mode = random.choice(MASK_MODE_SET + ["move","move"])  # 이동 가중치 조금 높임
    moved_to = None

    if mode == "black":
        cv2.rectangle(after,(x,y),(x+w,y+h),(0,0,0),-1)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode == "rect":
        patch = np.random.randint(0, 30, (h,w,3), dtype=np.uint8)
        after[y:y+h, x:x+w] = patch
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode == "inpaint":
        after[:] = inpaint_rect(after, x,y,w,h)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode == "blur":
        after[:] = blur_rect(after, x,y,w,h)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode == "pixel":
        after[:] = pixelate_rect(after, x,y,w,h, factor=0.15)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode == "move":
        prev = [x,y,w,h]
        after[:], moved_to = paste_move(after, x,y,w,h, W,H, existing=[])
        # 마스크: 원 위치 + 새 위치
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
        if moved_to is not None:
            nx,ny,nw,nh = moved_to
            cv2.rectangle(change_mask,(nx,ny),(nx+nw,ny+nh),255,-1)

    # 변경영역 일부만 남기기(컨투어 단위로 삭제)
    if random.random() < PARTIAL_KEEP_PROB:
        cnts,_ = cv2.findContours(change_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in cnts:
            if cv2.contourArea(c) < MIN_BOX_AREA: continue
            if random.random() < 0.5:
                cv2.drawContours(change_mask, [c], -1, 0, -1)

    return after, change_mask, moved_to

def process_split(split_name: str):
    in_root = BASE / split_name
    img_root = in_root / "images"
    lbl_root = in_root / "labels"

    out_b = OUT / split_name.replace("dataset_","") / "before_images"
    out_a = OUT / split_name.replace("dataset_","") / "after_images"
    out_y = OUT / split_name.replace("dataset_","") / "labels"
    for d in [out_b, out_a, out_y]: ensure_dir(d)

    meta = []
    classes = [d.name for d in img_root.iterdir() if d.is_dir() and not is_hidden(d)]
    total_pairs = 0

    for cls in classes:
        cls_img = img_root/cls
        cls_lbl = lbl_root/cls
        files = [p for p in cls_img.iterdir() if p.is_file() and p.suffix.lower() in IMG_EXTS and not is_hidden(p)]
        for imgp in files:
            base = imgp.stem
            lblp = cls_lbl/(base + YOLO_LBL_EXT)
            if not lblp.exists():
                # 라벨이 없으면 '변경 없음' 샘플로 만들 수도 있지만 기본은 스킵
                continue

            img = cv2.imread(str(imgp), cv2.IMREAD_COLOR)
            if img is None: continue
            H,W = img.shape[:2]
            boxes = read_yolo(lblp)
            if not boxes:
                # 박스가 없으면 '변경 없음' 샘플로 추가
                after = img.copy()
                change_mask = np.zeros((H,W), np.uint8)
            else:
                after = img.copy()
                change_mask = np.zeros((H,W), np.uint8)
                if random.random() < APPLY_MASK_PROB:
                    # 일부/전부 선택해서 변경
                    chosen = []
                    for b in boxes:
                        x,y,w,h = yolo_to_xywh(b, W,H)
                        chosen.append([x,y,w,h])
                    # 랜덤하게 일부만 변경
                    k = random.randint(1, max(1, len(chosen)))
                    for (x,y,w,h) in random.sample(chosen, k=k):
                        after, change_mask, _ = apply_change(after, change_mask, [x,y,w,h], W,H)
                else:
                    # 변화 없음 샘플
                    pass

            # 파일명 충돌 방지 위해 클래스 접두사
            out_name = f"{cls}__{imgp.name}"
            cv2.imwrite(str(out_b/out_name), img)
            cv2.imwrite(str(out_a/out_name), after)
            cv2.imwrite(str(out_y/(Path(out_name).stem + ".png")), change_mask)

            meta.append({
                "split": split_name.replace("dataset_",""),
                "class": cls,
                "before": str((out_b/out_name).as_posix()),
                "after":  str((out_a/out_name).as_posix()),
                "label":  str((out_y/(Path(out_name).stem + ".png")).as_posix())
            })
            total_pairs += 1

    # 메타 저장
    ensure_dir(OUT/"meta")
    with open(OUT/"meta"/f"pairs_{split_name.replace('dataset_','')}.json","w") as f:
        json.dump(meta, f, indent=2, ensure_ascii=False)

    print(f"[{split_name}] 생성 쌍: {total_pairs}")
    return total_pairs

# 실행
ensure_dir(OUT)
tot = 0
for sp in IN_SPLITS:
    tot += process_split(sp)
print(f"[DONE] 총 생성 쌍: {tot}")
print(f"출력 루트: {OUT}")

"""train/val 분할 결과"""

import os
def count_files(p):
    return sum(len(files) for _,_,files in os.walk(p))
root = "/content/drive/MyDrive/gayoung/ba/pairs_out_cd"
print("train before:", count_files(f"{root}/train/before_images"))
print("train after :", count_files(f"{root}/train/after_images"))
print("train labels:", count_files(f"{root}/train/labels"))
print("val   before:", count_files(f"{root}/val/before_images"))
print("val   after :", count_files(f"{root}/val/after_images"))
print("val   labels:", count_files(f"{root}/val/labels"))

"""**(train/val) before, aftert, change GT mask 예시**"""

for _ in range(10):
    show_sample("/content/drive/MyDrive/gayoung/ba/pairs_out_cd","train")

"""**(test) Before/After + GT 마스크 생성**"""

# === TEST 쌍/마스크 생성 ===
import os, json, random, cv2, numpy as np
from pathlib import Path

random.seed(42)

BASE = Path("/content/drive/MyDrive/gayoung/ba/label_space_data")
IN_SPLIT = "dataset_test"   # <-- 테스트 split
OUT = Path("/content/drive/MyDrive/gayoung/ba/pairs_out_cd")

IMG_EXTS = {".jpg",".jpeg",".png",".bmp",".webp"}
YOLO_LBL_EXT = ".txt"

# 변경 합성 파라미터
APPLY_MASK_PROB = 0.85
MASK_MODE_SET = ["black","inpaint","rect","blur","pixel"]
RECT_JITTER = 0.12
PARTIAL_KEEP_PROB = 0.25
MIN_BOX_AREA = 20*20
MAX_MOVED_TRIES = 10

def is_hidden(p): return p.name.startswith(".") or p.name.startswith("._")
def ensure_dir(p): p.mkdir(parents=True, exist_ok=True)

def read_yolo(txt_path: Path):
    boxes = []
    if not txt_path.exists(): return boxes
    for line in open(txt_path,"r"):
        ps = line.strip().split()
        if len(ps) < 5: continue
        _, cx, cy, w, h = ps[:5]
        try: boxes.append(tuple(map(float,(cx,cy,w,h))))
        except: pass
    return boxes

def yolo_to_xywh(box, W,H):
    cx,cy,w,h = box
    bw, bh = int(w*W), int(h*H)
    x = int((cx - w/2)*W); y = int((cy - h/2)*H)
    x = max(0,x); y = max(0,y)
    x2 = min(W-1, x+bw); y2 = min(H-1, y+bh)
    return x,y, max(2,x2-x), max(2,y2-y)

def jitter_rect(x,y,w,h,W,H,rate):
    jx, jy = int(w*rate), int(h*rate)
    x = max(0, min(W-1, x + random.randint(-jx, jx)))
    y = max(0, min(H-1, y + random.randint(-jy, jy)))
    w = max(2, w + random.randint(-jx, jx))
    h = max(2, h + random.randint(-jy, jy))
    x2 = max(0, min(W-1, x+w)); y2 = max(0, min(H-1, y+h))
    return x, y, x2-x, y2-y

def inpaint_rect(img, x,y,w,h):
    m = np.zeros(img.shape[:2], np.uint8)
    cv2.rectangle(m,(x,y),(x+w,y+h),255,-1)
    return cv2.inpaint(img, m, 3, cv2.INPAINT_TELEA)

def blur_rect(img, x,y,w,h):
    roi = img[y:y+h, x:x+w]
    if roi.size==0: return img
    k = max(3, (min(w,h)//10)*2+1)
    img[y:y+h, x:x+w] = cv2.GaussianBlur(roi,(k,k),0)
    return img

def pixelate_rect(img, x,y,w,h, factor=0.15):
    roi = img[y:y+h, x:x+w]
    if roi.size==0: return img
    dw, dh = max(1,int(w*factor)), max(1,int(h*factor))
    small = cv2.resize(roi,(dw,dh))
    img[y:y+h, x:x+w] = cv2.resize(small,(w,h), interpolation=cv2.INTER_NEAREST)
    return img

def paste_move(img, x,y,w,h, W,H):
    src = img[y:y+h, x:x+w].copy()
    for _ in range(MAX_MOVED_TRIES):
        nx = random.randint(0, max(0,W-w)); ny = random.randint(0, max(0,H-h))
        img[ny:ny+h, nx:nx+w] = src
        img[y:y+h, x:x+w] = 0
        return img, [nx,ny,w,h]
    return img, None

def apply_change(after, change_mask, box_xywh, W,H):
    x,y,w,h = box_xywh
    if w*h < MIN_BOX_AREA: return after, change_mask
    x,y,w,h = jitter_rect(x,y,w,h,W,H, RECT_JITTER)
    mode = random.choice(MASK_MODE_SET + ["move","move"])
    if mode=="black":
        cv2.rectangle(after,(x,y),(x+w,y+h),(0,0,0),-1)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode=="rect":
        patch = np.random.randint(0, 30, (h,w,3), dtype=np.uint8)
        after[y:y+h, x:x+w] = patch
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode=="inpaint":
        after[:] = inpaint_rect(after,x,y,w,h)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode=="blur":
        after[:] = blur_rect(after,x,y,w,h)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode=="pixel":
        after[:] = pixelate_rect(after,x,y,w,h,0.15)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
    elif mode=="move":
        after[:], moved = paste_move(after,x,y,w,h,W,H)
        cv2.rectangle(change_mask,(x,y),(x+w,y+h),255,-1)
        if moved is not None:
            nx,ny,nw,nh = moved
            cv2.rectangle(change_mask,(nx,ny),(nx+nw,ny+nh),255,-1)

    # 일부 컨투어 제거(부분 가림)
    if random.random() < PARTIAL_KEEP_PROB:
        cnts,_ = cv2.findContours(change_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in cnts:
            if cv2.contourArea(c) > MIN_BOX_AREA and random.random()<0.5:
                cv2.drawContours(change_mask,[c],-1,0,-1)
    return after, change_mask

def build_test():
    in_root = BASE/IN_SPLIT
    img_root = in_root/"images"
    lbl_root = in_root/"labels"

    out_b = OUT/"test"/"before_images"
    out_a = OUT/"test"/"after_images"
    out_y = OUT/"test"/"labels"
    for d in [out_b,out_a,out_y]: ensure_dir(d)

    meta = []
    classes = [d.name for d in img_root.iterdir() if d.is_dir() and not is_hidden(d)]
    total = 0

    for cls in classes:
        cls_img = img_root/cls
        cls_lbl = lbl_root/cls
        files = [p for p in cls_img.iterdir() if p.is_file() and p.suffix.lower() in IMG_EXTS and not is_hidden(p)]
        for imgp in files:
            base = imgp.stem
            lblp = cls_lbl/(base + YOLO_LBL_EXT)
            if not lblp.exists():
                # 라벨 없으면 스킵(원하면 변화 없음 샘플로 추가 가능)
                continue

            img = cv2.imread(str(imgp), cv2.IMREAD_COLOR)
            if img is None: continue
            H,W = img.shape[:2]
            boxes = read_yolo(lblp)

            after = img.copy()
            change_mask = np.zeros((H,W), np.uint8)
            if boxes and random.random() < APPLY_MASK_PROB:
                # 박스 중 일부만 변경
                bxywh = [yolo_to_xywh(b, W,H) for b in boxes]
                k = random.randint(1, max(1,len(bxywh)))
                for (x,y,w,h) in random.sample(bxywh, k=k):
                    after, change_mask = apply_change(after, change_mask, (x,y,w,h), W,H)

            # 저장(클래스 접두사)
            out_name = f"{cls}__{imgp.name}"
            cv2.imwrite(str(out_b/out_name), img)
            cv2.imwrite(str(out_a/out_name), after)
            cv2.imwrite(str(out_y/(Path(out_name).stem + ".png")), change_mask)

            meta.append({
                "split":"test",
                "class":cls,
                "before": str((out_b/out_name).as_posix()),
                "after":  str((out_a/out_name).as_posix()),
                "label":  str((out_y/(Path(out_name).stem + ".png")).as_posix()),
            })
            total += 1

    ensure_dir(OUT/"meta")
    with open(OUT/"meta"/"pairs_test.json","w") as f:
        json.dump(meta, f, indent=2, ensure_ascii=False)

    print(f"[dataset_test] 생성 쌍: {total}")
    print(f"출력: {OUT/'test'}")

build_test()

"""test 구축 결과"""

import os
root = "/content/drive/MyDrive/gayoung/ba/pairs_out_cd/test"
def count(p): return sum(len(fs) for _,_,fs in os.walk(p))
print("test before:", count(f"{root}/before_images"))
print("test after :", count(f"{root}/after_images"))
print("test labels:", count(f"{root}/labels"))

"""## 학습

### 데이터셋 로더
1. 목적: (before, after, mask) 쌍을 로드하고 크기/정규화를 일관 적용  
2. 입력: OUT/{train|val}/{before_images, after_images, labels}  
3. 전처리:
- 이미지: [0,1] 정규화, `HWC→CHW`  
- 마스크: **최근접 보간**으로 리사이즈, 0/255→{0,1}  
4. 반환: (before[3×H×W], after[3×H×W], mask[1×H×W])
"""

import glob, cv2, numpy as np, torch, torch.nn as nn, torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader
from pathlib import Path

ROOT_OUT = "/content/drive/MyDrive/gayoung/ba/pairs_out_cd"
IMG_SIZE = (384,384)
BATCH    = 4
EPOCHS   = 40
LR       = 1e-3
DEVICE   = "cuda" if torch.cuda.is_available() else "cpu"

class PairDataset2In(Dataset):
    def __init__(self, root, split="train", size=(384,384)):
        self.root = Path(root)/split
        self.size = size
        bs = sorted(glob.glob(str(self.root/"before_images/*")))
        A  = {Path(p).name:p for p in glob.glob(str(self.root/"after_images/*"))}
        self.items=[]
        for b in bs:
            nm = Path(b).name
            y  = self.root/"labels"/(Path(nm).stem+".png")
            if nm in A and y.exists():
                self.items.append((b, A[nm], str(y)))
    def __len__(self): return len(self.items)
    def __getitem__(self, i):
        pb, pa, py = self.items[i]
        b = cv2.imread(pb)[:,:,::-1]; a = cv2.imread(pa)[:,:,::-1]
        y = cv2.imread(py, cv2.IMREAD_GRAYSCALE)
        if self.size:
            b = cv2.resize(b, self.size, interpolation=cv2.INTER_AREA)
            a = cv2.resize(a, self.size, interpolation=cv2.INTER_AREA)
            y = cv2.resize(y, self.size, interpolation=cv2.INTER_NEAREST)
        b = (b.astype(np.float32)/255.).transpose(2,0,1)
        a = (a.astype(np.float32)/255.).transpose(2,0,1)
        y = (y>0).astype(np.float32)[None,...]
        return torch.from_numpy(b), torch.from_numpy(a), torch.from_numpy(y)

"""### 모델: TinyChangeUNet
1. **아이디어**: before, after, 그리고 절대차(diff, 1채널)를 합쳐 **7채널** 입력 → 1×1 conv로 3채널 축소 → MobileNetV3(Small) 백본(사전학습) 인코더 → 경량 디코더(TransposeConv + DWConvBlock) → 1채널 로짓 출력
2. **스킵/채널**: 인코더 피처를 24/40/64/96으로 맞춰 디코더와 결합
3. **출력**: 원 해상도로 bilinear 업샘플링된 로짓(시그모이드 전)
4. **장점**: 파라미터 수가 작고 모바일 친화적이며 CD(변화감지) 특화의 `diff` 입력을 사용

"""

import timm, torch
import torch.nn as nn
import torch.nn.functional as F

class DWConvBlock(nn.Module):
    def __init__(self, c_in, c_out):
        super().__init__()
        self.dw = nn.Conv2d(c_in, c_in, 3, 1, 1, groups=c_in, bias=False)
        self.bn1= nn.BatchNorm2d(c_in)
        self.pw = nn.Conv2d(c_in, c_out, 1, bias=False)
        self.bn2= nn.BatchNorm2d(c_out)
        self.act= nn.ReLU(inplace=True)
    def forward(self,x):
        x=self.dw(x); x=self.bn1(x); x=self.act(x)
        x=self.pw(x); x=self.bn2(x); x=self.act(x);
        return x

class TinyDecoder(nn.Module):
    def __init__(self, chs):  # [c1,c2,c3,c4]
        super().__init__()
        c1,c2,c3,c4 = chs
        self.up3 = nn.ConvTranspose2d(c4, c3, 2, 2); self.c3=DWConvBlock(c3+c3, c3)
        self.up2 = nn.ConvTranspose2d(c3, c2, 2, 2); self.c2=DWConvBlock(c2+c2, c2)
        self.up1 = nn.ConvTranspose2d(c2, c1, 2, 2); self.c1=DWConvBlock(c1+c1, c1)
    def forward(self, feats):
        f1,f2,f3,f4 = feats
        x = self.up3(f4); x=torch.cat([x,f3],1); x=self.c3(x)
        x = self.up2(x);  x=torch.cat([x,f2],1); x=self.c2(x)
        x = self.up1(x);  x=torch.cat([x,f1],1); x=self.c1(x)
        return x

class MobileNetV3Encoder(nn.Module):
    def __init__(self, out_indices=(0,1,2,3)):
        super().__init__()
        self.backbone = timm.create_model("mobilenetv3_small_100",
                                          pretrained=True, features_only=True,
                                          out_indices=out_indices)
        self.out_channels = self.backbone.feature_info.channels()
    def forward(self,x): return self.backbone(x)

class TinyChangeUNet(nn.Module):
    def __init__(self):
        super().__init__()
        # before(3) + after(3) + diff(1) = 7채널 → 3채널로 투영
        self.reduce = nn.Conv2d(7, 3, 1)
        self.encoder = MobileNetV3Encoder(out_indices=(0,1,2,3))
        c1,c2,c3,c4 = self.encoder.out_channels
        self.skip1 = nn.Conv2d(c1, 24, 1)
        self.skip2 = nn.Conv2d(c2, 40, 1)
        self.skip3 = nn.Conv2d(c3, 64, 1)
        self.bott  = nn.Conv2d(c4, 96, 1)
        self.decoder = TinyDecoder([24,40,64,96])
        self.head = nn.Conv2d(24, 1, 1)

    def forward(self, before, after):
        H, W = before.shape[-2], before.shape[-1]
        diff = torch.mean(torch.abs(before - after), dim=1, keepdim=True)  # N,1,H,W
        x = torch.cat([before, after, diff], dim=1)  # N,7,H,W
        x = self.reduce(x)
        f1,f2,f3,f4 = self.encoder(x)
        f1,f2,f3,f4 = self.skip1(f1), self.skip2(f2), self.skip3(f3), self.bott(f4)
        x = self.decoder([f1,f2,f3,f4])
        logit = self.head(x)
        return F.interpolate(logit, size=(H,W), mode='bilinear', align_corners=False)

"""### 학습/평가 루프
1. **핵심 기능**  
- **손실**: BCE(with `pos_weight`) + Tversky 혼합(AMP/F16 안전).  
- **클래스 불균형 완화**: train 소배치에서 **positive pixel ratio**를 추정해 `pos_weight` 자동 설정.  
- **스케줄러**: 2 epoch 워밍업 + Cosine Decay.  
- **EMA**: 부동 텐서만 추적, **EMA 가중치**로 검증/저장(안정성↑).  
- **임계값 스윕**: 매 epoch마다 `sweep_streaming`으로 **최적 th**와 (mIoU,F1) 로그.  
- **조기 종료**: 검증 F1 **개선폭 < 0.005**가 12epoch 지속 시 stop.  
- **로깅**: Loss/mIoU/F1 curve 저장(`live_curve.png`).

![018df41c-b2a7-4fce-857b-5fb91b2bce7a.png](data:image/png;base64,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)
"""

# ==== imports ====
import os, gc, math, numpy as np, torch, torch.nn as nn
from torch.utils.data import DataLoader
from tqdm.auto import tqdm
import matplotlib.pyplot as plt
from IPython.display import clear_output

# ==== 하이퍼파라미터 ====
ROOT_OUT = "/content/drive/MyDrive/gayoung/ba/pairs_out_cd"
IMG_SIZE  = 256
BATCH     = 8
EPOCHS    = 40
LR        = 3e-4                 # 손실 안정 위해 한 단계 낮춤 (원하면 1e-3로)
DEVICE    = "cuda" if torch.cuda.is_available() else "cpu"
SAVE_PATH = "/content/drive/MyDrive/gayoung/ba/change_tiny_mnv3_best.pth"

USE_POSTPROC = False             # 작은 블랍 제거(평가 시). 필요하면 True

torch.backends.cudnn.benchmark = True

# ------------------------------------------------------------
# 1) 손실 (FP16 안정화) + 디버그 지원
# ------------------------------------------------------------
class BCE_Tversky_FP16_dbg(nn.Module):
    def __init__(self, alpha=0.7, beta=0.3, eps=1e-3, pos_weight=None,
                 w_bce=0.6, w_tv=0.4):
        super().__init__()
        self.alpha, self.beta, self.eps = alpha, beta, eps
        self.w_bce, self.w_tv = w_bce, w_tv
        self.register_buffer("pos_weight_buf", None)
        if pos_weight is not None:
            self.pos_weight_buf = torch.as_tensor(pos_weight).reshape(1)
        self.bce = nn.BCEWithLogitsLoss(pos_weight=self.pos_weight_buf)

    def forward(self, pred, target, return_parts=False):
        pred = pred.clamp(-15, 15)
        b = self.bce(pred, target)                # BCE
        p = torch.sigmoid(pred)
        tp = (p*target).sum((2,3)).float()
        fp = (p*(1-target)).sum((2,3)).float()
        fn = ((1-p)*target).sum((2,3)).float()
        tv = (tp / (tp + self.alpha*fp + self.beta*fn + self.eps)).mean()
        tv_loss = (1.0 - tv).to(b.dtype)          # Tversky loss
        loss = self.w_bce*b + self.w_tv*tv_loss
        if return_parts:
            return loss, b.detach(), tv_loss.detach()
        return loss

# ------------------------------------------------------------
# 2) 지표 + (옵션) 작은 블랍 제거
# ------------------------------------------------------------
import torch.nn.functional as F
def clean_bin(pm_bin, k=3):
    # pm_bin: [N,1,H,W] 0/1 tensor
    return (F.avg_pool2d(pm_bin, k, 1, k//2) > 0.5).float()

@torch.no_grad()
def compute_metrics_from_sigmoid(pred_sigmoid, gt_bin, th=0.5, postproc=False):
    pm = (pred_sigmoid > th).float()
    if postproc:
        pm = clean_bin(pm, k=3)
    inter = (pm*gt_bin).sum((2,3))
    union = pm.sum((2,3)) + gt_bin.sum((2,3)) - inter + 1e-6
    iou = (inter/union).mean().item()
    f1  = (2*inter/(pm.sum((2,3))+gt_bin.sum((2,3))+1e-6)).mean().item()
    return iou, f1

# ------------------------------------------------------------
# 3) 로그릿 저장 없는 임계값 스윕 (EMA 상태에서 호출)
# ------------------------------------------------------------
def sweep_streaming(model, dl, device, th_grid, postproc=False):
    model.eval()
    t = torch.as_tensor(th_grid, device=device)   # [K]
    K = t.numel()
    inter = torch.zeros(K, device=device)
    union = torch.zeros(K, device=device)
    tp = torch.zeros(K, device=device)
    fp = torch.zeros(K, device=device)
    fn = torch.zeros(K, device=device)

    with torch.no_grad(), torch.amp.autocast('cuda', dtype=torch.float16):
        for b,a,y in dl:
            b,a,y = b.to(device), a.to(device), (y>0.5).to(device).float()
            logit = model(b,a).clamp(-15,15)
            p = torch.sigmoid(logit).float()
            if postproc:
                p = clean_bin((p>0.5).float(), k=3) * 1.0  # 근사 보정,
                p = p.clamp(0,1)                           # th를 다시 적용하므로 0/1 유지
                # 스윕 시엔 확률 기반이 더 낫지만, 후처리 쓰려면 간이근사로 사용

            p2 = p.flatten(2).transpose(1,2)       # [N,HW,1]
            y2 = y.flatten(2).transpose(1,2)
            pm = (p2 > t.view(1,1,-1)).float()     # [N,HW,K]

            pi = (pm*y2).sum(dim=(0,1))
            inter += pi
            u = pm.sum(dim=(0,1)) + y2.sum(dim=(0,1)) - pi
            union += torch.clamp(u, min=1e-6)

            tp += pi
            fp += (pm*(1-y2)).sum(dim=(0,1))
            fn += ((1-pm)*y2).sum(dim=(0,1))

    miou = (inter/union).cpu().numpy()
    f1   = (2*tp/torch.clamp(2*tp+fp+fn, min=1e-6)).cpu().numpy()
    j = int(np.argmax(f1))
    return {"th": float(t[j].item()), "mIoU": float(miou[j]), "F1": float(f1[j])}

# ------------------------------------------------------------
# 4) pos_weight 추정
# ------------------------------------------------------------
@torch.no_grad()
def estimate_pos_weight(dl, device, max_batches=20, clamp_to=10.0):
    pos, tot = 0, 0
    for i, (_, _, y) in enumerate(dl):
        y = (y>0.5).to(device).float()
        pos += y.sum().item()
        tot += y.numel()
        if i+1 >= max_batches: break
    neg = max(tot - pos, 1.0)
    raw = neg / max(pos, 1.0)
    pw  = float(np.sqrt(raw))
    if clamp_to is not None:
        pw = min(pw, clamp_to)
    return pw

# ------------------------------------------------------------
# 5) DataLoader
# ------------------------------------------------------------
tr = PairDataset2In(ROOT_OUT, "train", (IMG_SIZE, IMG_SIZE))
vl = PairDataset2In(ROOT_OUT, "val",   (IMG_SIZE, IMG_SIZE))

dl_tr = DataLoader(tr, batch_size=BATCH, shuffle=True,  num_workers=0, pin_memory=False, persistent_workers=False)
dl_vl = DataLoader(vl, batch_size=BATCH, shuffle=False, num_workers=0, pin_memory=False, persistent_workers=False)

# ------------------------------------------------------------
# 6) 모델/옵티마이저/코사인+워밍업/손실
# ------------------------------------------------------------
model = TinyChangeUNet().to(DEVICE)
opt   = torch.optim.AdamW(model.parameters(), lr=LR, weight_decay=1e-4, eps=1e-4)

pos_w = estimate_pos_weight(dl_tr, DEVICE, max_batches=20, clamp_to=10.0)
crit  = BCE_Tversky_FP16_dbg(alpha=0.7, beta=0.3, eps=1e-3,
                             w_bce=0.6, w_tv=0.4,
                             pos_weight=torch.tensor([pos_w], device=DEVICE))
print(f"[info] estimated pos_weight ≈ {pos_w:.2f}")

# 코사인 + 워밍업(에폭 기준)
WARMUP_EPOCHS = 2
ETA_MIN = 1e-5
BASE_LR = LR
def set_lr(lr):
    for g in opt.param_groups: g["lr"] = lr
def lr_at_epoch(ep):
    if ep < WARMUP_EPOCHS:
        return BASE_LR * (ep + 1) / max(1, WARMUP_EPOCHS)
    t = ep - WARMUP_EPOCHS
    T = max(1, EPOCHS - WARMUP_EPOCHS)
    return ETA_MIN + 0.5*(BASE_LR - ETA_MIN)*(1 + math.cos(math.pi * t / T))

# ------------------------------------------------------------
# 7) EMA (float 텐서만 추적)
# ------------------------------------------------------------
EMA_DECAY = 0.99
def build_ema(model):
    ema = {}
    for k, v in model.state_dict().items():
        if torch.is_floating_point(v):
            ema[k] = v.detach().clone()
    return ema

@torch.no_grad()
def ema_update(model, ema, decay=EMA_DECAY):
    msd = model.state_dict()
    for k in ema.keys():
        ema[k].mul_((decay)).add_(msd[k], alpha=1-decay)

@torch.no_grad()
def apply_ema_for_eval(model, ema):
    stash = {}
    msd = model.state_dict()
    for k, v in ema.items():
        stash[k] = msd[k].detach().clone()
        msd[k].copy_(v)
    return stash

@torch.no_grad()
def restore_from_stash(model, stash):
    msd = model.state_dict()
    for k, v in stash.items():
        msd[k].copy_(v)

ema = build_ema(model)

# ------------------------------------------------------------
# 8) 학습 루프
# ------------------------------------------------------------
scaler   = torch.amp.GradScaler('cuda')
history  = {"tr":[], "vl":[], "miou":[], "f1":[]}
best_f1  = -1.0
bad      = 0
min_delta = 0.005
patience  = 12
best_th   = 0.5
did_print_val_ratio = False

for ep in range(EPOCHS):
    set_lr(lr_at_epoch(ep))

    # ---- Train ----
    model.train(); run=0; n=0
    pbar = tqdm(dl_tr, desc=f"Epoch {ep+1}/{EPOCHS} [train]")
    for b,a,y in pbar:
        b,a,y = b.to(DEVICE), a.to(DEVICE), y.to(DEVICE)
        opt.zero_grad(set_to_none=True)
        with torch.amp.autocast('cuda', dtype=torch.float16):
            logit = model(b,a)
            loss  = crit(logit, y)
        scaler.scale(loss).backward()
        scaler.unscale_(opt)
        nn.utils.clip_grad_norm_(model.parameters(), 1.0)
        scaler.step(opt); scaler.update()
        ema_update(model, ema)                # step 후 EMA 갱신
        run += loss.item()*b.size(0); n += b.size(0)
        pbar.set_postfix(loss=f"{loss.item():.4f}", lr=opt.param_groups[0]["lr"])
        del b,a,y,logit,loss
    tr_loss = run/max(1,n)

    # ---- Valid (EMA로 평가 & 저장도 EMA로) ----
    model.eval(); run=0; n=0; ious=[]; f1s=[]
    stash = apply_ema_for_eval(model, ema)  # EMA 적용
    pbar = tqdm(dl_vl, desc=f"Epoch {ep+1}/{EPOCHS} [valid]")
    with torch.no_grad():
        pos_pix, tot_pix = 0, 0
        for b,a,y in pbar:
            b,a,y = b.to(DEVICE), a.to(DEVICE), y.to(DEVICE)
            with torch.amp.autocast('cuda', dtype=torch.float16):
                logit = model(b,a).clamp(-15,15)
                # 파트 로깅 원하면 아래처럼:
                # l, b_part, tv_part = crit(logit, y, return_parts=True)
                # loss = l.item()
                loss = crit(logit, y).item()
                s = torch.sigmoid(logit).float()
                mi, mf = compute_metrics_from_sigmoid(
                    s, (y>0.5).float(), th=best_th, postproc=USE_POSTPROC
                )
            run += loss*b.size(0); n += b.size(0)
            ious.append(mi); f1s.append(mf)
            pbar.set_postfix(loss=f"{loss:.4f}")
            if not did_print_val_ratio:
                pos_pix += (y>0.5).float().sum().item()
                tot_pix += y.numel()
            del b,a,y,logit,s
    if not did_print_val_ratio:
        did_print_val_ratio = True
        print(f"[val] positive pixel ratio ≈ {pos_pix/max(1,tot_pix):.6f}")

    vl_loss = run/max(1,n); miou=float(np.mean(ious)); mf1=float(np.mean(f1s))

    # ---- Save best & Early stop ----
    improved = (mf1 > best_f1 + min_delta)
    if improved:
        best_f1 = mf1; bad = 0
        torch.save(model.state_dict(), SAVE_PATH)   # 현재는 EMA 가중치가 들어가있음
        print("  ↳ best(F1) 갱신, 저장(EMA):", SAVE_PATH)
    else:
        bad += 1
        if bad >= patience:
            print("  ↳ early stop (F1)")
            restore_from_stash(model, stash)
            break

    # ---- 임계값 스윕 (EMA 상태에서 수행) ----
    grid = np.linspace(0.02, 0.40, 40)  # ← 요청한 구간으로 확장
    sweep = sweep_streaming(model, dl_vl, DEVICE, grid, postproc=USE_POSTPROC)
    best_th = sweep["th"]
    print(f"  ↳ [TH SWEEP/EMA] th={best_th:.2f} | mIoU={sweep['mIoU']:.3f} | F1={sweep['F1']:.3f}")

    # EMA 적용 전 가중치 복구
    restore_from_stash(model, stash)

    history["tr"].append(tr_loss); history["vl"].append(vl_loss)
    history["miou"].append(miou);  history["f1"].append(mf1)
    print(f"[{ep:02d}] train {tr_loss:.4f} | val {vl_loss:.4f} | mIoU {miou:.3f} | F1 {mf1:.3f} | th {best_th:.2f}")

    # ---- 메모리 정리 + 라이브 곡선 저장 ----
    torch.cuda.empty_cache(); gc.collect()
    clear_output(wait=True)
    plt.figure(figsize=(7,4))
    xs = np.arange(1, len(history["tr"]) + 1)
    plt.subplot(1,2,1); plt.title("Loss"); plt.plot(xs, history["tr"], label="train"); plt.plot(xs, history["vl"], label="val"); plt.legend(); plt.grid(True, alpha=0.3)
    plt.subplot(1,2,2); plt.title("Val mIoU / F1"); plt.plot(xs, history["miou"], label="mIoU"); plt.plot(xs, history["f1"], label="F1"); plt.legend(); plt.grid(True, alpha=0.3)
    plt.tight_layout(); plt.savefig("live_curve.png"); plt.close()

print("="*50)
print(f"학습 종료 | 총 Epoch: {len(history['tr'])}")
print(f"최고 F1(EMA): {best_f1:.3f} @ th={best_th:.2f}")
print(f"마지막 Epoch({len(history['tr'])-1})")
print(f"  train loss={history['tr'][-1]:.4f}")
print(f"  val loss  ={history['vl'][-1]:.4f}")
print(f"  mIoU={history['miou'][-1]:.3f}, F1={history['f1'][-1]:.3f}")
print("="*50)

"""TEST Eval"""

# ==== Self-contained TEST Eval (safe after Colab restart) ====
import os, glob, cv2, numpy as np, torch
import torch.nn.functional as F
from torch.utils.data import DataLoader
from tqdm.auto import tqdm

# --- 필수 클래스 준비 확인 ---
assert 'TinyChangeUNet' in globals(), "TinyChangeUNet 클래스를 먼저 정의/임포트하세요."
assert 'PairDataset2In' in globals(), "PairDataset2In 클래스를 먼저 정의/임포트하세요."

# --- 공통 설정 (먼저 정의!) ---
DEVICE = 'cuda' if torch.cuda.is_available() else 'cpu'
AMP_DEVICE = 'cuda' if DEVICE == 'cuda' else 'cpu'
AMP_DTYPE  = torch.float16 if DEVICE == 'cuda' else torch.bfloat16
ROOT_OUT   = "/content/drive/MyDrive/gayoung/ba/pairs_out_cd"
IMG_SIZE   = 256
BATCH      = 8
USE_POSTPROC = False
SAVE_PATH  = "/content/drive/MyDrive/gayoung/ba/change_tiny_mnv3_best.pth"

# --- 유틸 (이 셀에 같이 둠) ---
def clean_bin(pm_bin, k=3):
    return (F.avg_pool2d(pm_bin, k, 1, k//2) > 0.5).float()

@torch.no_grad()
def compute_metrics_from_sigmoid(pred_sigmoid, gt_bin, th=0.5, postproc=False):
    pm = (pred_sigmoid > th).float()
    if postproc:
        pm = clean_bin(pm, k=3)
    inter = (pm*gt_bin).sum((2,3))
    union = pm.sum((2,3)) + gt_bin.sum((2,3)) - inter + 1e-6
    iou = (inter/union).mean().item()
    f1  = (2*inter/(pm.sum((2,3))+gt_bin.sum((2,3))+1e-6)).mean().item()
    return iou, f1

@torch.no_grad()
def sweep_streaming(model, dl, device, th_grid=None, postproc=False):
    import numpy as _np
    if th_grid is None: th_grid = _np.linspace(0.35, 0.65, 13)
    t = torch.as_tensor(th_grid, device=device)   # [K]
    K = t.numel()
    inter = torch.zeros(K, device=device)
    union = torch.zeros(K, device=device)
    tp = torch.zeros(K, device=device)
    fp = torch.zeros(K, device=device)
    fn = torch.zeros(K, device=device)

    with torch.amp.autocast(device_type=AMP_DEVICE, dtype=AMP_DTYPE):
        for b,a,y in dl:
            b,a,y = b.to(device), a.to(device), (y>0.5).to(device).float()
            logit = model(b,a).clamp(-15,15)
            p = torch.sigmoid(logit).float()
            if postproc:
                p = clean_bin((p>0.5).float(), k=3) * 1.0
                p = p.clamp(0,1)

            p2 = p.flatten(2).transpose(1,2)       # [N,HW,1]
            y2 = y.flatten(2).transpose(1,2)
            pm = (p2 > t.view(1,1,-1)).float()     # [N,HW,K]
            pi = (pm*y2).sum(dim=(0,1))
            inter += pi
            u = pm.sum(dim=(0,1)) + y2.sum(dim=(0,1)) - pi
            union += torch.clamp(u, min=1e-6)
            tp += pi
            fp += (pm*(1-y2)).sum(dim=(0,1))
            fn += ((1-pm)*y2).sum(dim=(0,1))

    miou = (inter/union).cpu().numpy()
    f1   = (2*tp/torch.clamp(2*tp+fp+fn, min=1e-6)).cpu().numpy()
    j = int(np.argmax(f1))
    return {"th": float(t[j].item()), "mIoU": float(miou[j]), "F1": float(f1[j])}

# --- 모델 로드 (EMA가 저장된 체크포인트) ---
model = TinyChangeUNet().to(DEVICE).eval()
state = torch.load(SAVE_PATH, map_location=DEVICE)
model.load_state_dict(state, strict=True)

# --- 데이터로더 ---
vl = PairDataset2In(ROOT_OUT, "val",  (IMG_SIZE, IMG_SIZE))
dl_vl = DataLoader(vl, batch_size=BATCH, shuffle=False, num_workers=0)
ts = PairDataset2In(ROOT_OUT, "test", (IMG_SIZE, IMG_SIZE))
dl_ts = DataLoader(ts, batch_size=BATCH, shuffle=False, num_workers=0)

# --- 임계값 스윕 (val) ---
grid = np.linspace(0.02, 0.40, 40)
sweep = sweep_streaming(model, dl_vl, DEVICE, grid, postproc=USE_POSTPROC)
best_th = sweep["th"]
print(f"[VAL SWEEP] th={best_th:.3f} | mIoU={sweep['mIoU']:.3f} | F1={sweep['F1']:.3f}")

# --- 테스트 평가 + PNG 저장 (의존 함수 제거 버전: 연속 번호로 저장) ---
os.makedirs("test_preds", exist_ok=True)

@torch.no_grad()
def eval_and_dump(dl, th):
    ious, f1s = [], []
    global_idx = 0
    for b,a,y in tqdm(dl, desc="TEST"):
        b,a,y = b.to(DEVICE), a.to(DEVICE), (y>0.5).to(DEVICE).float()
        with torch.amp.autocast(device_type=AMP_DEVICE, dtype=AMP_DTYPE):
            logit = model(b,a).clamp(-15,15)
            s = torch.sigmoid(logit).float()

        mi, mf = compute_metrics_from_sigmoid(s, y, th=th, postproc=USE_POSTPROC)
        ious.append(mi); f1s.append(mf)

        pm = (s > th).float()
        if USE_POSTPROC: pm = clean_bin(pm, k=3)
        pm = (pm*255).byte().cpu().numpy()  # [N,1,H,W]

        N = pm.shape[0]
        for j in range(N):
            cv2.imwrite(f"test_preds/{global_idx:05d}.png", pm[j,0])
            global_idx += 1

        del b,a,y,logit,s,pm
    return float(np.mean(ious)), float(np.mean(f1s))

miou_ts, f1_ts = eval_and_dump(dl_ts, best_th)
print("="*60)
print(f"[TEST] mIoU={miou_ts:.3f} | F1={f1_ts:.3f} @ th={best_th:.2f} | postproc={USE_POSTPROC}")
print("pred png → ./test_preds/*.png")

"""test 결과 예시 시각화"""

import cv2, matplotlib.pyplot as plt, numpy as np

# 파일 경로
pb = "/content/drive/MyDrive/gayoung/ba/pairs_out_cd/test/after_images/STUDY_ROOM__Image_4.jpg"
pa = "/content/drive/MyDrive/gayoung/ba/pairs_out_cd/test/before_images/STUDY_ROOM__Image_4.jpg"
pp = "/content/test_preds/00029.png"

# 로드
B  = cv2.imread(pb, cv2.IMREAD_COLOR)[:,:,::-1]
A  = cv2.imread(pa, cv2.IMREAD_COLOR)[:,:,::-1]
PR = cv2.imread(pp, cv2.IMREAD_GRAYSCALE)

# 사이즈 정렬(After 기준)
H,W = A.shape[:2]
if B.shape[:2] != (H,W): B = cv2.resize(B, (W,H), interpolation=cv2.INTER_LINEAR)
if PR.shape[:2]!= (H,W): PR= cv2.resize(PR,(W,H), interpolation=cv2.INTER_NEAREST)

# overlay 함수
def overlay(rgb, mask, color=(0,255,255), alpha=0.35):
    if mask.dtype != np.uint8: mask = mask.astype(np.uint8)
    m = (mask>127).astype("uint8")
    over = (rgb*(1-alpha) + np.array(color,dtype=np.uint8).reshape(1,1,3)*alpha).astype(np.uint8)
    out = rgb.copy(); out[m>0] = over[m>0]
    return out

ov_pred = overlay(A, PR, color=(0,255,255), alpha=0.35)

# 시각화
plt.figure(figsize=(12,5))
plt.subplot(1,3,1); plt.imshow(B);       plt.title("Before"); plt.axis("off")
plt.subplot(1,3,2); plt.imshow(A);       plt.title("After"); plt.axis("off")
plt.subplot(1,3,3); plt.imshow(ov_pred); plt.title("Pred Overlay"); plt.axis("off")
plt.tight_layout()
plt.show()

"""## CoreML 변환"""

import torch

model = TinyChangeUNet().eval().to('cpu')
state = torch.load(SAVE_PATH, map_location='cpu')
model.load_state_dict(state, strict=True)

dummy_b = torch.rand(1,3,256,256)
dummy_a = torch.rand(1,3,256,256)

class Wrapper(torch.nn.Module):
    def __init__(self, net):
        super().__init__(); self.net = net
    def forward(self, before, after):
        logits = self.net(before, after)        # (1,1,H,W)
        return logits

ts = torch.jit.trace(Wrapper(model), (dummy_b, dummy_a))
torch.jit.save(ts, "change_ts.pt")

!pip install -U "coremltools>=7.2,<8", "numpy<2"

"""CoreML 변환"""

# ==== 0) imports ====
import torch, timm
import torch.nn as nn
import torch.nn.functional as F

# ==== 1) encoder  ====
class MobileNetV3Encoder(nn.Module):
    def __init__(self, out_indices=(0,1,2,3), pretrained=False, model_name="mobilenetv3_small_100"):
        super().__init__()
        self.backbone = timm.create_model(model_name, pretrained=pretrained,
                                          features_only=True, out_indices=out_indices)
        self.out_channels = self.backbone.feature_info.channels()
    def forward(self, x):
        return self.backbone(x)

# ==== 2) depthwise separable conv ====
class SepConvBN(nn.Module):
    def __init__(self, in_c, out_c):
        super().__init__()
        self.dw  = nn.Conv2d(in_c, in_c, 3, padding=1, groups=in_c, bias=False)
        self.bn1 = nn.BatchNorm2d(in_c)
        self.pw  = nn.Conv2d(in_c, out_c, 1, bias=False)
        self.bn2 = nn.BatchNorm2d(out_c)
    def forward(self, x):
        x = F.relu(self.bn1(self.dw(x)), inplace=True)
        x = F.relu(self.bn2(self.pw(x)), inplace=True)
        return x

# ==== 3) 디코더 ====
class DecoderCompat(nn.Module):
    def __init__(self):
        super().__init__()
        self.up3 = nn.ConvTranspose2d(96, 64, kernel_size=2, stride=2)  # matches [96,64,2,2]
        self.c3  = SepConvBN(128, 64)                                   # dw:128, pw:64
        self.up2 = nn.ConvTranspose2d(64, 40, kernel_size=2, stride=2)  # [64,40,2,2]
        self.c2  = SepConvBN(80, 40)                                    # dw:80,  pw:40
        self.up1 = nn.ConvTranspose2d(40, 24, kernel_size=2, stride=2)  # [40,24,2,2]
        self.c1  = SepConvBN(48, 24)                                    # dw:48,  pw:24
    def forward(self, s1, s2, s3, b):
        x = self.up3(b);  x = torch.cat([x, s3], dim=1); x = self.c3(x)
        x = self.up2(x);  x = torch.cat([x, s2], dim=1); x = self.c2(x)
        x = self.up1(x);  x = torch.cat([x, s1], dim=1); x = self.c1(x)
        return x

# ==== 4) 전체 네트워크  ====
class TinyChangeUNetV1Compat(nn.Module):
    def __init__(self):
        super().__init__()
        self.reduce  = nn.Conv2d(7, 3, 1)
        self.encoder = MobileNetV3Encoder(out_indices=(0,1,2,3), pretrained=False)
        c1, c2, c3, c4 = self.encoder.out_channels
        # skip을 24/40/64로 투영
        self.skip1 = nn.Conv2d(c1, 24, 1)
        self.skip2 = nn.Conv2d(c2, 40, 1)
        self.skip3 = nn.Conv2d(c3, 64, 1)
        # bottleneck을 96으로 투영 (up3 in_channels=96과 일치)
        self.bott  = nn.Conv2d(c4, 96, 1)
        self.decoder = DecoderCompat()
        self.head    = nn.Conv2d(24, 1, 1)
    def forward(self, before, after):
        diff = (after - before).abs().mean(dim=1, keepdim=True)
        x7   = torch.cat([before, after, diff], dim=1)
        x3   = self.reduce(x7)
        f1, f2, f3, f4 = self.encoder(x3)
        s1, s2, s3, b = self.skip1(f1), self.skip2(f2), self.skip3(f3), self.bott(f4)
        x = self.decoder(s1, s2, s3, b)
        return self.head(x)  # logits

# ==== 5) 내보내기용 래퍼 ====
class WrappedForExport(nn.Module):
    def __init__(self, net, mean=(0.485,0.456,0.406), std=(0.229,0.224,0.225)):
        super().__init__(); self.net = net.eval()
        self.register_buffer("mean", torch.tensor(mean).view(1,3,1,1))
        self.register_buffer("std",  torch.tensor(std ).view(1,3,1,1))
    def forward(self, before_u8, after_u8):
        b = (before_u8/255.0 - self.mean) / self.std
        a = (after_u8 /255.0 - self.mean) / self.std
        return self.net(b, a)

# ==== 6) 체크포인트 로드  ====
ckpt = "/content/drive/MyDrive/gayoung/ba/change_tiny_mnv3_best.pth"
net = TinyChangeUNetV1Compat().eval()
state = torch.load(ckpt, map_location="cpu")
net.load_state_dict(state, strict=True)

# ==== 7) TorchScript 저장 ====
H=W=256
wrapped = WrappedForExport(net).eval()
ts = torch.jit.trace(wrapped, (torch.rand(1,3,H,W)*255.0, torch.rand(1,3,H,W)*255.0))
ts.save("change_ts.pt")
print("✔ saved TorchScript -> change_ts.pt")

!pip install -U "coremltools>=7.2,<8" "numpy<2"

import coremltools as ct, torch
ts = torch.jit.load("change_ts.pt", map_location="cpu")
inp_b = ct.ImageType(name="before", shape=(1,3,256,256))
inp_a = ct.ImageType(name="after",  shape=(1,3,256,256))
mlmodel_fp16 = ct.convert(
    ts,
    inputs=[inp_b, inp_a],
    convert_to="mlprogram",
    compute_precision=ct.precision.FLOAT16,
    minimum_deployment_target=ct.target.iOS16,
)

mlmodel_fp16.save("change_unet_fp16.mlpackage")

"""로컬"""

# convert_to_mlpackage.py
import torch, torch.nn as nn, torch.nn.functional as F
import coremltools as ct
from pathlib import Path

# === 입력 TS 파일명 ===
TS_FILE = "change_ts.pt"

# 1) 원본 TorchScript 로드 (before, after 두 장을 인자로 받는 형태)
ts_core = torch.jit.load(TS_FILE, map_location="cpu").eval()

# 2) 전처리(/255 -> ImageNet mean/std) 래퍼 (항상 /255로, trace 안전)
IMN_MEAN = torch.tensor([0.485,0.456,0.406]).view(1,3,1,1)
IMN_STD  = torch.tensor([0.229,0.224,0.225]).view(1,3,1,1)

class PreprocWrapperTS(nn.Module):
    def __init__(self, ts_mod, out_size=None):
        super().__init__()
        self.ts = ts_mod
        self.out_size = out_size

    def _prep(self, x):
        x = x.float() / 255.0
        return (x - IMN_MEAN) / IMN_STD

    def forward(self, before, after):
        b, a = self._prep(before), self._prep(after)
        logits = self.ts(b, a)  # (N,1,H,W) logits
        if self.out_size and logits.shape[-1] != self.out_size:
            logits = F.interpolate(logits, size=(self.out_size, self.out_size),
                                   mode="bilinear", align_corners=False)
        return logits  # 시그모이드 미적용

# 출력 해상도 256
wrapped = PreprocWrapperTS(ts_core, out_size=None).eval()

# 3) TorchScript 재추적
ex_b = torch.zeros(1,3,256,256)
ex_a = torch.zeros(1,3,256,256)
ts_new = torch.jit.trace(wrapped, (ex_b, ex_a))
ts_new.save("change_ts_with_preproc.pt")

# 4) sanity check (0만 나오는지 확인)
with torch.no_grad():
    p = torch.sigmoid(ts_new(ex_b, ex_a))
    print("TS(probs) sanity:", p.min().item(), p.mean().item(), p.max().item(), "|", tuple(p.shape))

# 5) CoreML 변환: FP16, .mlpackage
inp_b = ct.ImageType(name="before", shape=(1,3,256,256))
inp_a = ct.ImageType(name="after",  shape=(1,3,256,256))
mlmodel = ct.convert(
    ts_new,
    inputs=[inp_b, inp_a],
    convert_to="mlprogram",
    minimum_deployment_target=ct.target.iOS16,
    compute_precision=ct.precision.FLOAT16
)
out_path = Path("change_unet_fp16.mlpackage")
mlmodel.save(str(out_path))
print("Saved:", out_path.resolve())